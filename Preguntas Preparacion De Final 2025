Ejercicio 1. Dar un algoritmo que decida si dos expresiones regulares denotan el mismo lenguaje. Justificar la correctitud.
Primero derivamos las E.R y obtenemos sus respectivos automatas (los asumimos Deterministicos pero si no lo fuesen los determinizamos como ya sabemos)
Llamamos A1={Q1,Σ,δ1,Q01,F1} al AFD que reconoce a ER1 y A2={Q2,Σ,δ1,Q02,F2} al AFD que reconoce a ER2
¿L1(A1)= L2(A2)? Para ver esto tenemos que ver la doble inclusion de los lenguajes.
L1 ⊆ L2 <--> L1 n (Σ* \ L2) = ∅ y L2 ⊆ L1 <--> L2 n (Σ* \ L1) = ∅ 
Luego, podemos construir los automatas que reconocen la interseccion pues los lenguajes reg. estan cerrados por interseccion (Σ* \ L es regular),
ahora para probar que la interseccion es vacia hay dos formas:
1. Lema de Pumping para lenguajes regulares: supongamos que L es reg, luego podemos probar que si no hay ninguna palabra entre n y 2n-1 no habra palabras 
mas grandes que ellas (pues serian necesariamente su concatenacion), queda probar que es vacio para las palabras menore a la const. de Pumping; dado que la
const de Pumping viene dada por la minima cantidad de estados del automata, podemos construir un AFD y ver que esta no acepte nada como veremos a continuacion .
2. ver que no lleguen a ningun estado final. Con probarlo con todas las permutaciones de simbolos para cadenas de tamaño menores a la ctte de Pumping ya 
sabremos entonces que el lenguaje es vacio; esto se debe hacer de algun modo sistematico de modo que no se dejen combinaciones fuera (BFS,DFS).
Luego, es claro que si alguna de las dos inclusiones no se cumple las E.R no eran equivalentes. Reconstruimos ahora el automata que sera la interseccion de
estos dos automatas, y por tanto el que acepte el lenguaje esperado.
A= A1xA2= {Q1xQ2,Σ,δ,(q01,q02),F1xF2} tal que L(A) = L(A1)n L(A2) donde δ: (Q1XQ2)XΣ -->(Q1xQ2), 
δ((p,q),a)-> (δ1(p,a),δ2(q,a)) para todo a en Σ y para todo (p,q) en Q1xQ2.
L(A)= {w ∈ Σ*: δ((q01,q02),w) ∈ F1xF2} =  (δ^)={δ((q01,q02),w) ∈ F1xF2}.

Ejercicio 2. Dar dos algoritmos distintos para determinar si el lenguaje aceptado por un automata finito dado es el conjunto de todas las cadenas del alfabeto. Justificar cada uno.
Para dar el algoritmo notamos que lo que se nos pide es ver que L(a) = Σ*, luego tenemos dos formas de proceder:
Alg 1: como el automata dado es finito, construimos su complemento y recorremos sistematicamente el automata para ver si reconoce alguna palabra, si lo hace entonces es claro que es falso.
Alg 2: usaremos el lema de Pumping para intentar encontrar una palabra que, deberia estar entre n y 2n -1 pero no esta, luego con esto nos alcanzara para demostrar que el automata no reconoce lo pedido.
Sea α = xyz una descomposicion de una palabra perteneciente al lenguaje, |α| >= N, entonces xy^iz debe pertenecer al lenguaje para todo i >= 0.
Usaremos una prop. intermedia para la demo: L ⊆ Σ* es finito <--> para todo w ∈ Σ*, |w| >= N, W ∉ L, con N la cte de Pumping.
Ahora, sabemos que no hace falta buscar para todos los N + k k >=0 mayores si no en el intervalo [N,2n).
=>) si L es finito, entonces queremos ver que no hay ningun w ∈ L tq |w| >= N, pues si lo hay entonces el conjunto sera infinito, esto es un absurdo por lo tanto solo tendremos palabras entre [o,N)
<=) como para todo w ∈ Σ*, |w| >= N, W ∉ L entonces L solo tendra palabras de tamaño menor a N o L es vacio, esto es un conjunto finito.
Habiendo demostrado la prop, podemos asegurar que si no encontramos ninguna palabra en el intervalo [N,2n) nos bastara para afirmar que el conj. es finito y nunca podra ser todas las cadenas del 
alfabeto. Si ademas faltase alguna combinacion en el intervalo [0,n) es claro que tampoco sera todas las cadenas del alfabeto pues faltaran palabras, esto se puede ver con un AF.

Ejercicio 3. Dar un algoritmo que determine si un lenguaje regular dado es infinito. Justificar.
Para ver que un lenguaje regular dado va a ser infinito nos alcanza con buscar en el intervalo de palabras de long. [N,2n), pues sabemos que con lema de Pumping todo lo bombeado sera infinito.
Sea  α = xyz una descomposicion de una palabra perteneciente al lenguaje, |α| >= N, entonces xy^iz debe pertenecer al lenguaje para todo i >= 0.
Demostracion: supongamos que L es infinito, pero no tiene palabras de long [N,2n), luego sea  α' = xy^iz la descomposicion para la palambra mas chica de L,sabemos |α'|>= 2N, sabemos que |y| >= 1 y
|xy|<=n  por lo tanto 0 < |y| <= N, luego por bombeo con i= 0  2N <=  |α'| < 2N - N (en el caso |Y| = N) esto es |α'|-|y| osea 2N <=  |α'| < N lo cual es un absurdo, y para cada tamaño de Y
en el intervalo [1,N] cubre el intervalo  [N,2n).

Ejercicio 4.¿Cuantos automatas finitos deterministas con dos estados pueden construirse sobre el alfabeto {0, 1}?
Para calcular esto necesitamos tener en cuenta(generico):
1. La cantidad de estados inicales distintos que podemos tener (viene dado por el diccionario)
2. La cantidad de δ que podemos dar para el alfabeto cumpliendo con ser deterministas.
3. La cantidad de estados finales.
 desarrollando un poco: 
1. es |Q| una vez que tenemos armado un automata podemos hacer que todos sus estados sean iniciales uno por uno(no simultaneamente)
2. cantidad de funciones a lo algebra 1 (f: A-> B #f = B^A) en el caso de δ: QxΣ -> Q esto es: |Q|^(|Q|x|Σ|)
3. esto es basicamente un partes de Q (este estado es final? si o no) 2^Q
Total: |Q|x |Q|^(|Q|x|Σ|)x2^Q

Sean L1 y L2 lenguajes regulares incluidos en Σ∗. Hacer un AFD con dos cintas de entrada que reconoce el lenguaje L = {(u, v) : u ∈ L1, v ∈ L2, |u| = |v|}
