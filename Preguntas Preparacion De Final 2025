Ejercicio 1. Dar un algoritmo que decida si dos expresiones regulares denotan el mismo lenguaje. Justificar la correctitud.
Primero derivamos las E.R y obtenemos sus respectivos automatas (los asumimos Deterministicos pero si no lo fuesen los determinizamos como ya sabemos)
Llamamos A1={Q1,Σ,δ1,Q01,F1} al AFD que reconoce a ER1 y A2={Q2,Σ,δ1,Q02,F2} al AFD que reconoce a ER2
¿L1(A1)= L2(A2)? Para ver esto tenemos que ver la doble inclusion de los lenguajes.
L1 ⊆ L2 <--> L1 n (Σ* \ L2) = ∅ y L2 ⊆ L1 <--> L2 n (Σ* \ L1) = ∅ 
Luego, podemos construir los automatas que reconocen la interseccion pues los lenguajes reg. estan cerrados por interseccion (Σ* \ L es regular),
ahora para probar que la interseccion es vacia hay dos formas:
1. Lema de Pumping para lenguajes regulares: supongamos que L es reg, luego podemos probar que si no hay ninguna palabra entre n y 2n-1 no habra palabras 
mas grandes que ellas (pues serian necesariamente su concatenacion), queda probar que es vacio para las palabras menore a la const. de Pumping; dado que la
const de Pumping viene dada por la minima cantidad de estados del automata, podemos construir un AFD y ver que esta no acepte nada como veremos a continuacion .
2. ver que no lleguen a ningun estado final. Con probarlo con todas las permutaciones de simbolos para cadenas de tamaño menores a la ctte de Pumping ya 
sabremos entonces que el lenguaje es vacio; esto se debe hacer de algun modo sistematico de modo que no se dejen combinaciones fuera (BFS,DFS).
Luego, es claro que si alguna de las dos inclusiones no se cumple las E.R no eran equivalentes. Reconstruimos ahora el automata que sera la interseccion de
estos dos automatas, y por tanto el que acepte el lenguaje esperado.
A= A1xA2= {Q1xQ2,Σ,δ,(q01,q02),F1xF2} tal que L(A) = L(A1)n L(A2) donde δ: (Q1XQ2)XΣ -->(Q1xQ2), 
δ((p,q),a)-> (δ1(p,a),δ2(q,a)) para todo a en Σ y para todo (p,q) en Q1xQ2.
L(A)= {w ∈ Σ*: δ((q01,q02),w) ∈ F1xF2} =  (δ^)={δ((q01,q02),w) ∈ F1xF2}.

Ejercicio 2. Dar dos algoritmos distintos para determinar si el lenguaje aceptado por un automata finito dado es el conjunto de todas las cadenas del alfabeto. Justificar cada uno.
Para dar el algoritmo notamos que lo que se nos pide es ver que L(a) = Σ*, luego tenemos dos formas de proceder:
Alg 1: como el automata dado es finito, construimos su complemento y recorremos sistematicamente el automata para ver si reconoce alguna palabra, si lo hace entonces es claro que es falso.
Alg 2: usaremos el lema de Pumping para intentar encontrar una palabra que, deberia estar entre n y 2n -1 pero no esta, luego con esto nos alcanzara para demostrar que el automata no reconoce lo pedido.
Sea α = xyz una descomposicion de una palabra perteneciente al lenguaje, |α| >= N, entonces xy^iz debe pertenecer al lenguaje para todo i >= 0.
Usaremos una prop. intermedia para la demo: L ⊆ Σ* es finito <--> para todo w ∈ Σ*, |w| >= N, W ∉ L, con N la cte de Pumping.
Ahora, sabemos que no hace falta buscar para todos los N + k k >=0 mayores si no en el intervalo [N,2n).
=>) si L es finito, entonces queremos ver que no hay ningun w ∈ L tq |w| >= N, pues si lo hay entonces el conjunto sera infinito, esto es un absurdo por lo tanto solo tendremos palabras entre [o,N)
<=) como para todo w ∈ Σ*, |w| >= N, W ∉ L entonces L solo tendra palabras de tamaño menor a N o L es vacio, esto es un conjunto finito.
Habiendo demostrado la prop, podemos asegurar que si no encontramos ninguna palabra en el intervalo [N,2n) nos bastara para afirmar que el conj. es finito y nunca podra ser todas las cadenas del 
alfabeto. Si ademas faltase alguna combinacion en el intervalo [0,n) es claro que tampoco sera todas las cadenas del alfabeto pues faltaran palabras, esto se puede ver con un AF.

Ejercicio 3. Dar un algoritmo que determine si un lenguaje regular dado es infinito. Justificar.
Para ver que un lenguaje regular dado va a ser infinito nos alcanza con buscar en el intervalo de palabras de long. [N,2n), pues sabemos que con lema de Pumping todo lo bombeado sera infinito.
Sea  α = xyz una descomposicion de una palabra perteneciente al lenguaje, |α| >= N, entonces xy^iz debe pertenecer al lenguaje para todo i >= 0.
Demostracion: supongamos que L es infinito, pero no tiene palabras de long [N,2n), luego sea  α' = xy^iz la descomposicion para la palambra mas chica de L,sabemos |α'|>= 2N, sabemos que |y| >= 1 y
|xy|<=n  por lo tanto 0 < |y| <= N, luego por bombeo con i= 0  2N <=  |α'| < 2N - N (en el caso |Y| = N) esto es |α'|-|y| osea 2N <=  |α'| < N lo cual es un absurdo, y para cada tamaño de Y
en el intervalo [1,N] cubre el intervalo  [N,2n).

Ejercicio 4.¿Cuantos automatas finitos deterministas con dos estados pueden construirse sobre el alfabeto {0, 1}?
Para calcular esto necesitamos tener en cuenta(generico):
1. La cantidad de estados inicales distintos que podemos tener (viene dado por el diccionario)
2. La cantidad de δ que podemos dar para el alfabeto cumpliendo con ser deterministas.
3. La cantidad de estados finales.
 desarrollando un poco: 
1. es |Q| una vez que tenemos armado un automata podemos hacer que todos sus estados sean iniciales uno por uno(no simultaneamente)
2. cantidad de funciones a lo algebra 1 (f: A-> B #f = B^A) en el caso de δ: QxΣ -> Q esto es: |Q|^(|Q|x|Σ|)
3. esto es basicamente un partes de Q (este estado es final? si o no) 2^Q
Total: |Q|x |Q|^(|Q|x|Σ|)x2^Q

Ejercicio 5.Sean L1 y L2 lenguajes regulares incluidos en Σ∗. Hacer un AFD con dos cintas de entrada que reconoce el lenguaje L = {(u, v) : u ∈ L1, v ∈ L2, |u| = |v|}
Sea M1= {Q1,Σ,δ1,q01,F1} el AFD que reconoce L1 y sea M2= {Q2,Σ,δ2,q02,F2} el AFD que reconoce a L2, queremos construir un AFD A tal que L(A) = L, luego notamos que lo que necesitamos es que los pares
(u,v) sean reconocidos por sus respectivos automatas, para ello definiremos A= {Q,Σ,δ,(q01,q02),F1xF2} donde Q = Q1XQ2,y definiremos:
δ1: Q1xΣ -> Q1, δ2: Q2xΣ -> Q2, δ: (Q1xQ2)x(ΣxΣ) -> Q. δ= {(p,q) ∈ Q1xQ2, (a,b) ∈ ΣxΣ : δ((p,q),(ab))= (δ1(p,a),δ2(q,b)) ∈ Q} =  δ(^)={δ((q01,q02),(a,b)) ∈ F1xF2}

Ejercicio 6. Decir Verdadero o Falso y justificar:
1. Para cada AF hay infinitos AFD que reconocen el mismo lenguaje.Verdadero
Justificacion: dos automatas con estados A,B,C y Q0,Q1,Q2 con iguales transiciones estados finales, estado inicial etc son iguales. Ademas si el AFD original tiene un estado trampa explicito, siempre
podemos hacerlo que transicione a un nuevo estado trampa_n ad infinitum.
2. Si L es libre de contexto, todo subconjunto de L es libre de contexto. Falso.
Sea L={a^nb^nc^m|n,m >= 0} es un lenguaje libre de contexto (lee igual cantidades de a y b y luego solo consume c) pero el subconjunto {a^nb^nc^n|n >= 0} no es libre de contexto
3. Los automatas finitos determinısticos reconocen una cadena de longitud n en exactamente n transiciones. Verdadero
Un automata finito va a transicionar los N simbolos de su cadena y por mas que pase por un e.f. en el camino solo lo aceptara si esta en un estado final, si lo pensamos como un grafo (y sabiendo AFD)
esto es solo tiene un camino a recorrer.
4. Los automatas de pila determinısticos reconocen una cadena de longitud n en exactamente n transiciones.Falso
Basta con apilar un lenguaje regular {a^n| n>0} y hacer que cuando termina de consumir a,Z0/Z0 simplemente pase por lambda,Z0/Z0 al estado final, luego esto termina en mas de n pasos y el AP es determ. 
5. Las maquinas de Turing determinısticas reconocen una cadena de longitud n en exactamente n transiciones.Falso
Una MTD si bien tiene bien definidas sus transiciones, puede estar chequeando cosas que necesiten mas de una pasada en la cinta lo cual lleva mas de N transiciones (algun lenguaje que tenga mas de 2 cosas
a contar ya no es un AP y la MT no puede contar todo de una pasada).
6. Sea M un AFD y sea M^R el automata que resulta de revertir funcion de transicion. L(M) interseccion L(M^R) es regular. Verdadero
El automata resultante de revertir la funcion de transicion sera finito(posiblemente no det.) pues simplemente estamos 'cambiando el sentido de las flechas' luego la interseccion de lenguajes 
regulares es regular
